# logic.py — hybrid Grok AI + fallback mode
import os, json, random, time, logging, httpx
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from config import Config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class BotLogic:
    def __init__(self, bot):
        self.bot = bot
        self.coin_name = os.environ.get("COIN_NAME", "NPEPE")
        self.ticker = os.environ.get("TICKER", "NPEPE")
        self.contract = os.environ.get("CONTRACT_ADDRESS", "N/A")
        self.pumpfun = os.environ.get("PUMP_FUN_LINK", "")
        self.website = os.environ.get("WEBSITE_URL", "")
        self.telegram = os.environ.get("TELEGRAM_URL", "")
        self.x = os.environ.get("X_URL", "")
        self.ai_enabled = os.environ.get("AI_REPLY_ENABLED", "false").lower() == "true"

        # Load fallback texts
        try:
            with open("bot_texts.json", "r", encoding="utf-8") as f:
                self.texts = json.load(f)
        except Exception:
            self.texts = {
                "HYPE": ["LFG! To the moon!", "Pump it, frens!", "Buy the dip!"],
                "WISDOM": ["In chaos we trust.", "The meme is the mission.", "HODL strong, fren."],
                "GREET_NEW_MEMBERS": ["Welcome to the swamp!", "Another frog joins the cult 🐸"]
            }

        # AI configuration
        self.grok_url = os.environ.get("GROK_API_URL", "https://api.groq.ai/v1/chat/completions")
        self.grok_key = os.environ.get("GROK_API_KEY", "")
        self.grok_model = os.environ.get("GROK_MODEL", "llama3-8b-8192")

        self.register_handlers()

    # ========== Register Telegram handlers ==========
    def register_handlers(self):
        self.bot.message_handler(commands=["start","help"])(self.cmd_start)
        self.bot.message_handler(content_types=["new_chat_members"])(self.greet_new_member)
        self.bot.message_handler(func=lambda m: True, content_types=["text"])(self.handle_text)

    # ========== Core Commands ==========
    def cmd_start(self, message):
        txt = f"🐸 Welcome to {self.coin_name} ({self.ticker})\n\nThe meme has evolved. In chaos we trust."
        kb = InlineKeyboardMarkup()
        if self.pumpfun:
            kb.add(InlineKeyboardButton("💰 Buy Now", url=self.pumpfun))
        if self.website:
            kb.add(InlineKeyboardButton("🌐 Website", url=self.website))
        if self.telegram:
            kb.add(InlineKeyboardButton("📣 Telegram", url=self.telegram))
        self.bot.reply_to(message, txt, reply_markup=kb)

    def greet_new_member(self, message):
        for member in message.new_chat_members:
            name = getattr(member, "first_name", "fren")
            greet_msg = random.choice(self.texts.get("GREET_NEW_MEMBERS", [f"Welcome {name}!"]))
            self.bot.send_message(message.chat.id, greet_msg)

    # ========== AI + fallback logic ==========
    def handle_text(self, message):
        text = (message.text or "").lower()
        chat_id = message.chat.id

        # 🔹 Simple keyword routing
        if "contract" in text or "ca" in text:
            self.bot.send_message(chat_id, f"🧾 Contract:\n`{self.contract}`", parse_mode="Markdown")
            return
        if "pump" in text or "moon" in text or "buy" in text:
            self.bot.send_message(chat_id, random.choice(self.texts.get("HYPE", ["LFG!"])))
            return
        if "roadmap" in text or "phase" in text:
            self.bot.send_message(chat_id, "🗺 Phase 1: Chaos unleashed.\nPhase 2: Meme expansion.\nPhase 3: The Great Pump.")
            return

        # 🔹 Otherwise: use AI Grok if available
        if self.ai_enabled and self.grok_key:
            ai_reply = self.ask_grok(message.text)
            if ai_reply:
                self.bot.send_message(chat_id, ai_reply)
                return

        # 🔹 Offline fallback
        fallback = random.choice(self.texts.get("WISDOM", ["Stay based, fren."]))
        self.bot.send_message(chat_id, fallback)

    # ========== Grok Integration ==========
    def ask_grok(self, user_input: str) -> str:
        """Call Grok AI, return reply or None if failed."""
        headers = {"Authorization": f"Bearer {self.grok_key}", "Content-Type": "application/json"}
        payload = {
            "model": self.grok_model,
            "messages": [
                {"role": "system", "content": f"You are {self.coin_name}'s Telegram bot — a chaotic meme coin frog that replies with humor, hype, and meme energy."},
                {"role": "user", "content": user_input}
            ],
            "temperature": 0.6,
            "max_tokens": 300
        }
        try:
            with httpx.Client(timeout=10.0) as client:
                r = client.post(self.grok_url, json=payload, headers=headers)
                r.raise_for_status()
                data = r.json()
                return data["choices"][0]["message"]["content"]
        except Exception as e:
            logger.warning(f"[AI offline] {e}")
            return None
