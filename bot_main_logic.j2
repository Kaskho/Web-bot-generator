# logic.py ‚Äî Main Bot (AI Grok + Delay + Cache Notify)
import os, json, random, time, logging, httpx, threading
from flask import Flask, request
from telebot import TeleBot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

BOT_TOKEN = os.environ.get("BOT_TOKEN")
bot = TeleBot(BOT_TOKEN)

SIDEKICK_URL = os.environ.get("SIDEKICK_URL", "")  # URL ke sidekick endpoint
AI_ENABLED = os.environ.get("AI_REPLY_ENABLED", "true").lower() == "true"
GROK_API_KEY = os.environ.get("GROK_API_KEY", "")
GROK_URL = os.environ.get("GROK_API_URL", "https://api.groq.ai/v1/chat/completions")
GROK_MODEL = os.environ.get("GROK_MODEL", "llama3-8b-8192")

COIN_NAME = os.environ.get("COIN_NAME", "NPEPE")

# Load fallback texts
try:
    with open("bot_texts.json", "r", encoding="utf-8") as f:
        TEXTS = json.load(f)
except Exception:
    TEXTS = {"HYPE": ["LFG!", "Pump it!"], "WISDOM": ["In chaos we trust."]}


# ============= AI REPLY =============
def ask_grok(user_input: str) -> str:
    if not (AI_ENABLED and GROK_API_KEY):
        return None
    headers = {"Authorization": f"Bearer {GROK_API_KEY}", "Content-Type": "application/json"}
    payload = {
        "model": GROK_MODEL,
        "messages": [
            {"role": "system", "content": f"You are {COIN_NAME}'s main bot ‚Äî hype, chaotic, and clever. Keep it short and meme-like."},
            {"role": "user", "content": user_input}
        ],
        "temperature": 0.7,
        "max_tokens": 200
    }
    try:
        with httpx.Client(timeout=10.0) as client:
            r = client.post(GROK_URL, json=payload, headers=headers)
            r.raise_for_status()
            data = r.json()
            return data["choices"][0]["message"]["content"]
    except Exception as e:
        logger.warning(f"[AI Offline] {e}")
        return None


# ============= MESSAGE HANDLER =============
@bot.message_handler(commands=["start"])
def cmd_start(msg):
    bot.reply_to(msg, f"üê∏ Welcome to {COIN_NAME}! Let‚Äôs build meme chaos together.")


@bot.message_handler(func=lambda m: not m.from_user.is_bot, content_types=["text"])
def handle_message(msg):
    """Handle normal user messages with delay + cache notify"""
    threading.Thread(target=delayed_response, args=(msg,)).start()


def delayed_response(msg):
    """Respond to message after 10 seconds"""
    time.sleep(10)
    text = msg.text.lower()
    chat_id = msg.chat.id

    reply = ask_grok(text)
    if not reply:
        reply = random.choice(TEXTS.get("HYPE", ["LFG!"]))

    bot.send_message(chat_id, reply)
    logger.info(f"[MainBot Reply] {reply[:40]}")

    # Notify sidekick
    if SIDEKICK_URL:
        try:
            httpx.post(f"{SIDEKICK_URL}/cache_message", json={"text": msg.text})
            logger.info(f"Sent cache to sidekick: {msg.text[:30]}")
        except Exception as e:
            logger.warning(f"Failed to notify sidekick: {e}")


# ============= WEBHOOK / CACHE ENDPOINT =============
@app.route("/cache_message", methods=["POST"])
def cache_from_sidekick():
    """Sidekick can also send cache if needed"""
    data = request.get_json()
    logger.info(f"[Received cache from sidekick] {data}")
    return {"status": "ok"}


@app.route("/", methods=["GET"])
def home():
    return f"{COIN_NAME} Bot active."


# ============= START BOT =============
def run():
    app.run(host="0.0.0.0", port=10000)


if __name__ == "__main__":
    threading.Thread(target=run).start()
    bot.infinity_polling()
