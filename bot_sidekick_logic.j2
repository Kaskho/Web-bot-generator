# logic.py ‚Äî Smart Sidekick with 20s Delay & MainBot Sync
import os, json, random, time, logging, httpx, threading, re
from flask import Flask, request
from telebot import TeleBot

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

BOT_TOKEN = os.environ.get("BOT_TOKEN")
bot = TeleBot(BOT_TOKEN)

AI_ENABLED = os.environ.get("AI_REPLY_ENABLED", "true").lower() == "true"
GROK_API_KEY = os.environ.get("GROK_API_KEY", "")
GROK_URL = os.environ.get("GROK_API_URL", "https://api.groq.ai/v1/chat/completions")
GROK_MODEL = os.environ.get("GROK_MODEL", "llama3-8b-8192")
COIN_NAME = os.environ.get("COIN_NAME", "NPEPE")
ROLE = os.environ.get("ROLE", "SIDEKICK")

# Cache pesan yang sudah dijawab main bot
CACHE_FILE = "main_cache.json"
if not os.path.exists(CACHE_FILE):
    json.dump([], open(CACHE_FILE, "w"))

try:
    with open("bot_texts.json", "r", encoding="utf-8") as f:
        TEXTS = json.load(f)
except Exception:
    TEXTS = {"HYPE": ["Let's go frog army!", "Swamp energy rising üê∏"], "WISDOM": ["Silence is bullish."]}


# ============= AI REPLY =============
def ask_grok(user_input: str) -> str:
    if not (AI_ENABLED and GROK_API_KEY):
        return None
    headers = {"Authorization": f"Bearer {GROK_API_KEY}", "Content-Type": "application/json"}
    payload = {
        "model": GROK_MODEL,
        "messages": [
            {"role": "system", "content": f"You are {COIN_NAME}'s sidekick frog ‚Äî funny, slightly sarcastic, reacts to chat vibe. Keep replies short and witty."},
            {"role": "user", "content": user_input}
        ],
        "temperature": 0.9,
        "max_tokens": 150
    }
    try:
        with httpx.Client(timeout=10.0) as client:
            r = client.post(GROK_URL, json=payload, headers=headers)
            r.raise_for_status()
            data = r.json()
            return data["choices"][0]["message"]["content"]
    except Exception as e:
        logger.warning(f"[AI Offline] {e}")
        return None


# ============= HANDLE CHAT =============
@bot.message_handler(func=lambda m: not m.from_user.is_bot, content_types=["text"])
def handle_message(msg):
    threading.Thread(target=delayed_sidekick_reply, args=(msg,)).start()


def delayed_sidekick_reply(msg):
    time.sleep(20)
    text = msg.text.lower()
    chat_id = msg.chat.id

    # Skip if this text is already handled by main bot
    if _is_in_cache(text):
        logger.info(f"[Skip] Main bot already replied: {text[:40]}")
        return

    # Only reply if message contains trigger words or emotion
    if not _is_trigger(text):
        return

    reply = ask_grok(text)
    if not reply:
        reply = _fallback(text)

    bot.send_message(chat_id, reply)
    logger.info(f"[Sidekick Reply] {reply[:50]}")


def _is_trigger(text: str) -> bool:
    triggers = ["why", "wen", "pump", "moon", "lol", "?", "buy", "frog"]
    return any(t in text for t in triggers)


def _is_in_cache(text: str) -> bool:
    try:
        cache = json.load(open(CACHE_FILE, "r"))
        return any(t.lower() in text.lower() for t in cache)
    except:
        return False


def _fallback(text: str) -> str:
    if re.search(r"pump|moon|buy", text, re.IGNORECASE):
        return random.choice(TEXTS.get("HYPE", ["Let's gooo"]))
    if "?" in text:
        return random.choice(TEXTS.get("WISDOM", ["Patience, fren."]))
    return random.choice(TEXTS.get("HYPE", ["Stay meme-motivated üê∏"]))


# ============= CACHE ENDPOINT =============
@app.route("/cache_message", methods=["POST"])
def cache_message():
    """Receive cache from main bot"""
    data = request.get_json()
    text = data.get("text", "")
    if text:
        cache = json.load(open(CACHE_FILE, "r"))
        if text not in cache:
            cache.append(text)
            json.dump(cache[-100:], open(CACHE_FILE, "w"))  # keep last 100 entries
            logger.info(f"[Cache added] {text[:40]}")
    return {"status": "ok"}


@app.route("/", methods=["GET"])
def home():
    return f"{COIN_NAME} Sidekick active."


# ============= START BOT =============
def run():
    app.run(host="0.0.0.0", port=10000)


if __name__ == "__main__":
    threading.Thread(target=run).start()
    bot.infinity_polling()
